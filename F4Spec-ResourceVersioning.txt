Fedora 4 API Specifications[a][b]
Resource Versioning
1. Introduction
2. Terminology
3. Conformance
4. Versioned Resources (LDP-Rv, URI-R)
5. Version Resources (LDP-Rm, URI-M)
6. Version Containers (LDP-Cv, URI-T)
7. Vary-Post/Vary-Put Response Header
8. Implementation Patterns
1. Acknowledgements


1 Introduction
This specification is an attempt to reconcile the semantics and client patterns of LDP, the versioning requirements of Fedora repositories, and the well-established version identification and navigation scheme delineated in the Memento specification.


2 Terminology
* LDP-R: A Linked Data Platform Resource. This may be an LDP RDF Source or an LDP Non-RDF Source.
* LDP-Rm: A LDP-R that is a version of another resource LDP-Rv. LDP-Rm are identified by Memento URI-M and contained by LDP-Cv.
* LDP-Rv: A LDP-R that is versioned.Synonymous with Memento URI-R.
* LDP-C: A Linked Data Platform Container.
* LDP-Cv: A Linked Data Platform Version Container
* URI-R: A type of versioned resource defined in the Memento framework.
* URI-M: A type of resource that is defined in the Memento framework representing a version of a given URI-R.
* TimeGate: A type of resource defined in the Memento framework providing Accept-Datetime -varied negotiation of versions of an URI-R.
* TimeMap: A type of resource defined in the Memento framework that contains a machine-readable listing of URI-Ms connected to a given URI-R.


3 Conformance
* 1 Introduction non-normative
* 2 Terminology normative
* 3 Conformance normative
* 4 Versioned Resources normative
* 5 Version Resources normative
* 6 Version containers normative
* 7 Implementation Patterns non-normative
* A Acknowledgments non-normative
4 Versioned Resources (LDP-Rv)
4.1 General
A versioned resource is indicated by an interaction model TBD. It otherwise follows the relevant LDP specification with the additional behaviors below.
4.2 HTTP GET
4.2.1 Common HTTP Request Headers
Link@rel="type" of the URI of the versionable resource interaction model TBD
4.2.2 Common HTTP Response Headers
Link@rel="timemap" to LDP-Cv - this indicates that the resource is versioned
Link@rel="timegate" to something, if links to itself it MUST respect Accept-Datetime per Memento.
OPTIONAL header that indicates the resource will mint a version with a header, perhaps Vary-Post/Vary-Put; lack of this header indicates that explicit minting if available is advertised via OPTIONS on the LDP-Cv 
4.2.3 HTTP Headers for LDP-R that are also TimeGate
4.2.3.1 Request Headers
Accept-Datetime, per Memento
4.2.3.2 Response Headers
Vary: Accept-Datetime, per Memento


4.3 HTTP HEAD
See HTTP GET
5 Version Resources (LDP-Rm Mementos)
5.1 General
When a LDP-R is created with a Link header indicating versioning, it is created as both an LDP Resource and a Memento: a LDP-Rm. LDP-Rm SHOULD be invariant:[c] While they may be deleted, they SHOULD NOT be modifiable once created.


5.2 HTTP DELETE
DELETE is optional. If DELETE is supported[d], the Fedora/LDP server is responsible for all behaviors implied by the containment of the LDP-Rm.


5.3 HTTP GET
MUST be supported, as is the case for all LDP-R.
5.3.1 HTTP Response Headers
Link@rel="canonical original" indicating the versioned LDP-Rv
Link@rel=timegate
Link@rel="timemap version-history" indicating the LDP-Cv
Link@rel="next memento"
Link@rel="previous memento"
Memento-Datetime
5.3.2 HTTP Response Headers for LDP-NR?[e]
Ought a variant header be provided to indicate that the description, if available, is a timegate or not? It is not strictly necessary: Regardless of how they are synchronized, the LDP server would be able to identify the relevant version of the LDP-RS descriptor. On the other hand: if the LDP-Rv has iana:describedby, all LDP-Rm versionOf LDP-Rv should have a iana:describedby.[f]


5.4 HTTP HEAD
MUST be supported.
5.4.1 HTTP Response Headers


5.5 HTTP OPTIONS
MUST be supported. Always Allow: GET, HEAD, OPTIONS as per LDP.
MAY Allow: DELETE if clients can remove a version from the version history.


5.6 HTTP PATCH
SHOULD NOT be supported.


5.7 HTTP POST
MUST NOT be supported.


5.8 HTTP PUT
OPTIONAL. SHOULD NOT be supported. Subject to same constraints as PUT to update, further requires Memento headers. Discourage, discourage.
6 Version Containers (LDP-Cv)
6.1 General
When a LDP-R is created with a Link header indicating versioning, a version container (LDP-Cv)[g][h][i] is created that contains Memento-identified resources (LDP-Rm) capturing the current state of the described LDP-R. The LDP-Cv is both a TimeMap[j][k] per RFC7089 (Memento) and a Container.[l][m][n][o][p][q][r][s][t] The LDP impl MUST indicate TimeMap in the same way it indicates the Container interaction model of the resource (headers, inserted rdf:type, etc). The LDP-Cv MUST respond to GET Accept: application/link-format as indicated in RFC 7089 section 5 and specified in RFC 6690 section 7.3.


Non-normative: The application/link-format representation is not required to include all statements in the LDP-Cv graph.


6.2 HTTP DELETE
Optional, SHOULD remove the versioning interaction model from the original resource.


6.3 HTTP GET
6.3.1 HTTP Request Headers
6.3.2 HTTP Response Headers
Link@rel="type" to indicate Timemap


6.4 HTTP HEAD
6.4.1 HTTP Response Headers


6.5 HTTP OPTIONS
MUST Allow: GET, HEAD, OPTIONS as per LDP.
MAY Allow: DELETE if the versioning behavior is removable by deleting the LDP-Cv. See 6.2 for requirements on DELETE if supported.
MAY Allow: PATCH if the LDP-Cv has mutable properties. See 6.6 for requirements on PATCH if supported.
MAY Allow: POST if versions are explicitly minted by a client. See 6.7 for requirements on POST if supported.
6.6 HTTP PATCH
OPTIONAL. Discourage. MUST NOT modify containment triples if supported.


6.7 HTTP POST
OPTIONAL. If a LDP-Cv Allow: POST, POST should be understood to create a new LDP-Rm contained by the LDP-Cv, reflecting the state of the LDP-Rv at the time of the POST. If supported, and all LDP-Rm statements are server-managed, Accept-Post SHOULD indicate that no request body is accepted ("Accept-Post: */*; p=0.0" has minimal conflict with LDP), [u][v][w][x]and POST with a request body SHOULD respond with 4xx and a link to an appropriate constraints document (see LDP 4.2.1.6). As per LDP, any resource created via POST, in this case a LDP-Rm) should be advertised in the response's Location header.


If a LDP-Cv accepts POST with a request body, it SHOULD respect a Memento-Datetime request header to mint the URI-M. Absent this header, it MUST use the current time.


Non-normative note: If LDP-Cv implementations do not Allow: POST, the constraints document indicated in Link@rel=constrainedby for the LDP-Cv should describe the versioning mechanism. Disallowing POST suggests that the LDP server will manage LDP-Rm creation; see 7.2.1
6.8 HTTP PUT[y][z][aa][ab]
OPTIONAL. If an implementation accepts PUT, it SHOULD reject created URIs that are not URI-m. It MUST respond to rejected request bodies as specified in LDP. LDP-Cv MUST reflect the range of times indicated by contained LDP-Rm.


Non-normative: An implementation that accepts PUT is not required to validate content.


7 Vary-Post/Vary-Put
Non-normative: When Post/Put to a resource optionally mints an identified version, the resource indicates it with Vary-Post/Vary-Put with the name of the request header indicating it. When a LDP-Cv supports Post/Put with a body, and allows client-specification of URI-M datetime, Vary-Post/Vary-Put: Memento-Datetime. 
8 Implementation Patterns
8.1 Introduction
This is a non-normative section describing the way the normative specification might be applied to discoverable versioning patterns. If an implementation of a LDP-Cv does not support POST to mint versions, that is advertisable (MUST be) via OPTIONS, etc. Presumably the implementation would automatically mint versions, but this is ancillary to this specification- the contract is simply with how the LDP-Rm's would be discovered, and how they should act. Following the example of Memento, it would be useful to outline such implementation in non-normative sections down here, but first things first.


8.2 LDP-Rm Creation Patterns
8.2.1 Server-Managed LDP-Rm Creation (ajs6f)
Upon POST[ac]/PUT/PATCH to the LDP-R/URI-R, a new LDP-Rm/URI-M is created, contained in the version container. This LDP-Rm/URI-M is the version of the original LDP-R/URI-R that was just created.


8.2.2 Client-Managed LDP-Rm Creation, Server-Managed Content (barmintor)
A LDP-Rm/URI-M is created on POST to the LDP-Cv[ad][ae]. 
The LDP-Cv has a constraints document indicating that it does not accept a request body/entity on POST.[af][ag][ah][ai]
        a. Use a separate request to create the LDP-Rm, for example by posting an empty body.
        b. Use a header on the original creation interaction to request a new LDP-Rm.
        c. Use Memento-Datetime as request header to provide datetime of the state to create the new LDP-Rm from, combined with Vary-Post on the LDP-Cv


8.2.3 Client-Managed LDP-Rm Creation, Client-Managed Content (azaroth42)
A LDP-Rm/URI-M is created on POST/PUT to the LDP-Cv, with an entity body.  This pattern is the most open, least server managed, but could be important particularly for migration from other systems into spec compatible systems. Use Case:  A web archive that manages its descriptive metadata and the HTML NonRdfSources, which have been gathered over the last 20 years by heritrix.  Use case 2: Have previous RdfSources from previous systems that manage versioning (such as Marmotta) and need to migrate those Mementos. 
        Plus C from above :)


Responses from GET requests to the LDP-R/URI-R include a Link@rel=’version-history’ pointing to the LDP-Cv as well as a Link@rel=timemap to the same LDP-Cv.


8.3 LDP Considerations
Advertising default behaviors in server constraints document


If the LDP server allows reuse of URIs after deletion
Does this undermine the meaning of the version history?


If the LDP-Rv contains its LDP-Cv
This pattern will make it impossible to identify previous versions of a deleted resource.


LDP-Cv as a DirectContainer
Minimizing header inspection for read-only clients with http://purl.org/dc/terms/hasVersion or similar.
8.4 Memento Considerations
If the LDP-Cv/TimeMap is also the TimeGate
Responses from GET requests to the version container (LDP-Cv) will vary depending on the presence or absence of an Accept-Datetime header in the request.
* In the absence of an Accept-Datetime header, the response will be an appropriately constructed TimeMap.
* In the presence of  an Accept-Datetime header, the response will be a redirect to the appropriately chosen LDP-Rm/URI-M, i.e. the version container will behave like a TimeGate.


A Acknowledgments
Thanks to Aaron Birkland, Adam Soroka, Andrew Woods, Anonymous, Ben Armintor ,Bethany Seeger, Jared Whiklo, Joshua Westgard, LDP-Next, Rob Sanderson, Sergio Fernández, Tom Johnson
[a]Note: header responses of versioned resources must be specified, i.e. Link:describedby.
[b]Right. Most of the details there should come out of Memento, but we need to say that out loud so that everyone hears it.
[c]+1. If LDP-Rm is a memento of another LDP-Rv ... should the creation be automatic and just a snapshot of the state?
[d]I consider this to be an important feature for our possible use of versions in Fedora -- to be able to discard versions that are no longer of use. Glad to see the option is here.
[e]LDP-NR that are also versioned (LDP-NRv)? I don't think there should be a difference between RdfSource Original resources and NonRdfSource Originals
[f]Yes. Because it's an LDP-NR.... the Memento-ness is orthogonal
[g]I think we're right to reach for "container" here. It's natural and unsurprising, and I think the semantics will work. But we do have to think about what a new LDP type means. Is this a "mixin" on an arbitrary container type? Is it a subtype of some particular container type? The former is powerful but difficult, the latter simpler but may miss some use cases.
[h]Would it be possibly to simply add an rdf:type noting the fact that this LDP-Cv is a version-container? Ideally, we will move towards incorporating a versioning pattern into LDP, but would a marker type suffice for the initial round?
[i]I agree Container seems the most natural fit.  I don't have strong feelings about the best way to implement that, though the idea of a versions container seems analogous to the "files" container that is sometimes used to gather binaries pertaining to a particular resource. In my opinion the fewer special behaviors and characteristics of these containers, the better.  Andrew's suggestion of a simple marker in the early phase seems like it could work.
[j]TImeMaps MUST support application/link-header format ... triples on the container that don't serialize into that format are silently dropped? I don't see a problem with that, just want to be sure :)
[k]Yes: Need to link RFC 7089 section 5 and RFC 6690 7.3; application/link-format response serialization is a MUST that would need to be in the TCK
[l]I think the version container is a _view_ of the version history, a way to access it and pieces of it. Mutation continues to occur via the same messages as used for unversioned resources, POST/PUT to the LDP-R/URI-R.
[m]+1
[n]Okay, does that mean we can actually lay out an invariant? "A version container is read-only."
[o]+awoods@duraspace.org , if you didn't originate suggestion 2 (the Cv accepts mutation messages) who did?
[p]I do not know who made suggestion 2... maybe +armintor@gmail.com
[q]Enforcing read-only semantics on the LDP-Cv makes sense... it is server-managed.
[r]I am lost to what y'all mean. POST to the Cv doesn't mutate the resource, it mints a version, right?
[s]That is the model of "Alternative 2", yes.
[t]https://en.wikipedia.org/wiki/Alternative_3
[u]For LDP-Rv, I think the empty body is fine... every triple is considered to be server managed. The */*;p=0.0 is a bit strange ... but ... I don't have a better suggestion. Was just the content-type of the resource in A-P considered, with content-length of 0 on the post?
[v]I think the content-length=0 makes sense from the client, but I think we also need a way for the server to advertise that clients ought not to send an entity, right? So that you know whether the Rm graph is server-managed or client-managed.
[w]In the face of concurrency, would it be reasonable for an implementation to accept POST with a body containing the specific state of the resource the client would like minted into an LDP-Rm, or is it the intent of this spec to specifically disallow this sort of pattern?  (i.e. if an LDP-Cv accepts POST, it MUST NOT accept POSTs with an entity body)
[x]Good point: I think it needs not take such a strong stand, but must specify how an implementation that doesn't accept a body advertises itself to clients. I think a hint is necessary.
[y]If the memento is being created from a previous system, e.g. migrating from some CMS with good versioning support, then PUT (as in create) might be useful to send content, rather than the empty POST ?
[z]I think this is a good point, especially for an implementation-agnostic specification.
[aa]We should add a note here re: inheriting the obligation of PUT from LDP, and clarifying that the implementations supporting PUT are free to validate content as they will. Maybe also propose Memento-Datetime as a request header used as a Slug?
[ab]Actually, the former makes more sense for POST with a body; PUT should just use the intended URI-M.
[ac]This seems to have to do with the idea that creating children of a container modifies the container, which seems intuitive in some ways. But that information (containment) is system managed. Do we have to version system-managed and user-managed data independently?
[ad]I don't follow this. For consonance with LDP and to avoid incoherence, I think "LDP-Rm is created on POST to the original LDP-R, which is itself a Memento URI-R" instead.
[ae]What I like about this approach of POSTing to the LDP-Cv is that the creation of a version (LDP-Rm) is an explicit action, not an implicit action on every update to the LDP-R.
[af]What is the semantic for this message? "Create a new version identical to the current version."?
[ag]I don't think the LDP-Cv/TimeMap accepts POST or PUT. I don't understand how that makes sense in Memento-world.
[ah]I think an empty POST to mint a new URI-M makes more sense than a PUT, for sure. But I think we can also defer these decisions to the impl so long as the impl can indicate what its expectations are. So I've elaborated the draft POST behavior as optional behavior with additional requirements above, and indicated what not supporting POST implies where relevant.
[ai]The imperative thing is to identify how the interaction model should be navigated by clients trying to discover versions, and how creation (or lack thereof) is advertised to clients who may update.